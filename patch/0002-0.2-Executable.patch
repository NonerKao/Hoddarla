From 541ff80fc984b3b357a54b652647dfb25fcfb103 Mon Sep 17 00:00:00 2001
From: "Alan (Quey-Liang) Kao" <alankao@andestech.com>
Date: Wed, 21 Jul 2021 23:04:06 +0800
Subject: [PATCH 02/20] 0.2 Executable

---
 src/cmd/link/internal/ld/asmb.go     |   1 +
 src/cmd/link/internal/ld/sym.go      |   2 +-
 src/cmd/link/internal/riscv64/obj.go |   2 +-
 src/internal/poll/fd_opensbi.go      |  82 +++++
 src/os/dir_opensbi.go                |  16 +
 src/os/exec_opensbi.go               |  78 +++++
 src/os/executable_opensbi.go         |  12 +
 src/os/file_opensbi.go               | 188 ++++++++++
 src/os/path_opensbi.go               |  19 +
 src/os/rawconn.go                    |   4 +-
 src/os/stat_opensbi.go               |  26 ++
 src/os/sys_opensbi.go                |   9 +
 src/runtime/cputicks.go              |   4 +-
 src/runtime/env_posix.go             |   4 +-
 src/runtime/lock_opensbi.go          | 172 ++++++++++
 src/runtime/mem_opensbi.go           |  48 +++
 src/runtime/netpoll_stub.go          |   4 +-
 src/runtime/os_opensbi.go            | 173 ++++++++++
 src/runtime/rt0_opensbi_riscv64.s    |  14 +
 src/runtime/stubs2.go                |   4 +-
 src/runtime/stubs3.go                |   4 +-
 src/runtime/timestub2.go             |   3 +-
 src/syscall/dir_opensbi.go           |  33 ++
 src/syscall/dirent.go                |   4 +-
 src/syscall/env_opensbi.go           |  26 ++
 src/syscall/fs_opensbi.go            | 131 +++++++
 src/syscall/syscall_opensbi.go       | 364 ++++++++++++++++++++
 src/syscall/tables_opensbi.go        | 495 +++++++++++++++++++++++++++
 src/time/sys_opensbi.go              |  55 +++
 src/time/zoneinfo_opensbi.go         | 142 ++++++++
 30 files changed, 2102 insertions(+), 17 deletions(-)
 create mode 100644 src/internal/poll/fd_opensbi.go
 create mode 100644 src/os/dir_opensbi.go
 create mode 100644 src/os/exec_opensbi.go
 create mode 100644 src/os/executable_opensbi.go
 create mode 100644 src/os/file_opensbi.go
 create mode 100644 src/os/path_opensbi.go
 create mode 100644 src/os/stat_opensbi.go
 create mode 100644 src/os/sys_opensbi.go
 create mode 100644 src/runtime/lock_opensbi.go
 create mode 100644 src/runtime/mem_opensbi.go
 create mode 100644 src/runtime/os_opensbi.go
 create mode 100644 src/runtime/rt0_opensbi_riscv64.s
 create mode 100644 src/syscall/dir_opensbi.go
 create mode 100644 src/syscall/env_opensbi.go
 create mode 100644 src/syscall/fs_opensbi.go
 create mode 100644 src/syscall/syscall_opensbi.go
 create mode 100644 src/syscall/tables_opensbi.go
 create mode 100644 src/time/sys_opensbi.go
 create mode 100644 src/time/zoneinfo_opensbi.go

diff --git a/src/cmd/link/internal/ld/asmb.go b/src/cmd/link/internal/ld/asmb.go
index d6ecb2895b..5ecab642bc 100644
--- a/src/cmd/link/internal/ld/asmb.go
+++ b/src/cmd/link/internal/ld/asmb.go
@@ -102,6 +102,7 @@ func asmb2(ctxt *Link) {
 		objabi.Hlinux,
 		objabi.Hnetbsd,
 		objabi.Hopenbsd,
+		objabi.Hopensbi,
 		objabi.Hsolaris:
 		asmbElf(ctxt)
 	}
diff --git a/src/cmd/link/internal/ld/sym.go b/src/cmd/link/internal/ld/sym.go
index 72639962e2..9f35b2a38c 100644
--- a/src/cmd/link/internal/ld/sym.go
+++ b/src/cmd/link/internal/ld/sym.go
@@ -75,7 +75,7 @@ func (ctxt *Link) computeTLSOffset() {
 	default:
 		log.Fatalf("unknown thread-local storage offset for %v", ctxt.HeadType)
 
-	case objabi.Hplan9, objabi.Hwindows, objabi.Hjs, objabi.Haix:
+	case objabi.Hplan9, objabi.Hwindows, objabi.Hjs, objabi.Haix, objabi.Hopensbi:
 		break
 
 	case objabi.Hlinux,
diff --git a/src/cmd/link/internal/riscv64/obj.go b/src/cmd/link/internal/riscv64/obj.go
index 557e8932c9..6a47a81ccf 100644
--- a/src/cmd/link/internal/riscv64/obj.go
+++ b/src/cmd/link/internal/riscv64/obj.go
@@ -53,7 +53,7 @@ func Init() (*sys.Arch, ld.Arch) {
 
 func archinit(ctxt *ld.Link) {
 	switch ctxt.HeadType {
-	case objabi.Hlinux:
+	case objabi.Hlinux, objabi.Hopensbi:
 		ld.Elfinit(ctxt)
 		ld.HEADR = ld.ELFRESERVE
 		if *ld.FlagTextAddr == -1 {
diff --git a/src/internal/poll/fd_opensbi.go b/src/internal/poll/fd_opensbi.go
new file mode 100644
index 0000000000..367081f26d
--- /dev/null
+++ b/src/internal/poll/fd_opensbi.go
@@ -0,0 +1,82 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package poll
+
+import (
+	"errors"
+	"time"
+)
+
+type FD struct {
+	fdmu    fdMutex
+	Destroy func()
+	isFile  bool
+}
+
+func (fd *FD) destroy() error {
+	return nil
+}
+
+func (fd *FD) Close() error {
+	return nil
+}
+
+func (fd *FD) Read(fn func([]byte) (int, error), b []byte) (int, error) {
+	return 0, nil
+}
+
+func (fd *FD) Write(fn func([]byte) (int, error), b []byte) (int, error) {
+	return 0, nil
+}
+
+func (fd *FD) SetDeadline(t time.Time) error {
+	return nil
+}
+
+// SetReadDeadline sets the read deadline associated with fd.
+func (fd *FD) SetReadDeadline(t time.Time) error {
+	return nil
+}
+
+// SetWriteDeadline sets the write deadline associated with fd.
+func (fd *FD) SetWriteDeadline(t time.Time) error {
+	return nil
+}
+
+func setDeadlineImpl(fd *FD, t time.Time, mode int) error {
+	return nil
+}
+
+func (fd *FD) ReadLock() error {
+	return nil
+}
+
+func (fd *FD) ReadUnlock() {
+	return
+}
+
+func isHangup(err error) bool {
+	return false
+}
+
+func isInterrupted(err error) bool {
+	return false
+}
+
+func IsPollDescriptor(fd uintptr) bool {
+	return false
+}
+
+func (fd *FD) RawControl(f func(uintptr)) error {
+	return errors.New("not implemented")
+}
+
+func (fd *FD) RawRead(f func(uintptr) bool) error {
+	return errors.New("not implemented")
+}
+
+func (fd *FD) RawWrite(f func(uintptr) bool) error {
+	return errors.New("not implemented")
+}
diff --git a/src/os/dir_opensbi.go b/src/os/dir_opensbi.go
new file mode 100644
index 0000000000..94a7d013a2
--- /dev/null
+++ b/src/os/dir_opensbi.go
@@ -0,0 +1,16 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+func (file *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error) {
+	return nil, nil, nil, nil
+}
+
+type dirEntry struct{}
+
+func (de dirEntry) Name() string            { return "" }
+func (de dirEntry) IsDir() bool             { return false }
+func (de dirEntry) Type() FileMode          { return 0 }
+func (de dirEntry) Info() (FileInfo, error) { return nil, nil }
diff --git a/src/os/exec_opensbi.go b/src/os/exec_opensbi.go
new file mode 100644
index 0000000000..305c79058b
--- /dev/null
+++ b/src/os/exec_opensbi.go
@@ -0,0 +1,78 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+import (
+	"time"
+)
+
+func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {
+	return nil, nil
+}
+
+func (p *Process) writeProcFile(file string, data string) error {
+	return nil
+}
+
+func (p *Process) signal(sig Signal) error {
+	return nil
+}
+
+func (p *Process) kill() error {
+	return nil
+}
+
+func (p *Process) wait() (ps *ProcessState, err error) {
+	return nil, nil
+}
+
+func (p *Process) release() error {
+	return nil
+}
+
+func findProcess(pid int) (p *Process, err error) {
+	return nil, nil
+}
+
+type ProcessState struct {
+	pid int // The process's id.
+}
+
+// Pid returns the process id of the exited process.
+func (p *ProcessState) Pid() int {
+	return p.pid
+}
+
+func (p *ProcessState) exited() bool {
+	return true
+}
+
+func (p *ProcessState) success() bool {
+	return true
+}
+
+func (p *ProcessState) sys() interface{} {
+	return nil
+}
+
+func (p *ProcessState) sysUsage() interface{} {
+	return nil
+}
+
+func (p *ProcessState) userTime() time.Duration {
+	return 0 * time.Millisecond
+}
+
+func (p *ProcessState) systemTime() time.Duration {
+	return 0 * time.Millisecond
+}
+
+func (p *ProcessState) String() string {
+	return ""
+}
+
+func (p *ProcessState) ExitCode() int {
+	return 0
+}
diff --git a/src/os/executable_opensbi.go b/src/os/executable_opensbi.go
new file mode 100644
index 0000000000..90bbf10d30
--- /dev/null
+++ b/src/os/executable_opensbi.go
@@ -0,0 +1,12 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi
+// +build opensbi
+
+package os
+
+func executable() (string, error) {
+	return "", nil
+}
diff --git a/src/os/file_opensbi.go b/src/os/file_opensbi.go
new file mode 100644
index 0000000000..2c9a194ec1
--- /dev/null
+++ b/src/os/file_opensbi.go
@@ -0,0 +1,188 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+import (
+	"time"
+)
+
+func fixLongPath(path string) string {
+	return path
+}
+
+type file struct {
+	fd         int
+	name       string
+	dirinfo    *dirInfo // nil unless directory being read
+	appendMode bool     // whether file is opened for appending
+}
+
+func (f *File) Fd() uintptr {
+	return 0
+}
+
+func NewFile(fd uintptr, name string) *File {
+	return nil
+}
+
+type dirInfo struct {
+	buf  [1024]byte // buffer for directory I/O
+	nbuf int        // length of buf; return value from Read
+	bufp int        // location of next record in buf.
+}
+
+func epipecheck(file *File, e error) {
+}
+
+func syscallMode(i FileMode) (o uint32) {
+	return 0
+}
+
+func openFileNolog(name string, flag int, perm FileMode) (*File, error) {
+	return nil, nil
+}
+
+func (f *File) Close() error {
+	return nil
+}
+
+func (file *file) close() error {
+	return nil
+}
+
+func (f *File) Stat() (FileInfo, error) {
+	return nil, nil
+}
+
+func (f *File) Truncate(size int64) error {
+	return nil
+}
+
+func (f *File) chmod(mode FileMode) error {
+	return nil
+}
+
+func (f *File) Sync() error {
+	return nil
+}
+
+func (f *File) read(b []byte) (n int, err error) {
+	return 0, nil
+}
+
+func (f *File) pread(b []byte, off int64) (n int, err error) {
+	return 0, nil
+}
+
+func (f *File) write(b []byte) (n int, err error) {
+	return 0, nil
+}
+
+func (f *File) pwrite(b []byte, off int64) (n int, err error) {
+	return 0, nil
+}
+
+func (f *File) seek(offset int64, whence int) (ret int64, err error) {
+	return 0, nil
+}
+
+func Truncate(name string, size int64) error {
+	return nil
+}
+
+func Remove(name string) error {
+	return nil
+}
+
+func hasPrefix(s, prefix string) bool {
+	return false
+}
+
+func rename(oldname, newname string) error {
+	return nil
+}
+
+func chmod(name string, mode FileMode) error {
+	return nil
+}
+
+func Chtimes(name string, atime time.Time, mtime time.Time) error {
+	return nil
+}
+
+func Pipe() (r *File, w *File, err error) {
+	return nil, nil, nil
+}
+
+func Link(oldname, newname string) error {
+	return nil
+}
+
+func Symlink(oldname, newname string) error {
+	return nil
+}
+
+func Readlink(name string) (string, error) {
+	return "", nil
+}
+
+func Chown(name string, uid, gid int) error {
+	return nil
+}
+
+func Lchown(name string, uid, gid int) error {
+	return nil
+}
+
+func (f *File) Chown(uid, gid int) error {
+	return nil
+}
+
+func tempDir() string {
+	return ""
+
+}
+
+func (f *File) Chdir() error {
+	return nil
+}
+
+func (f *File) setDeadline(time.Time) error {
+	return nil
+}
+
+func (f *File) setReadDeadline(time.Time) error {
+	return nil
+}
+
+func (f *File) setWriteDeadline(time.Time) error {
+	return nil
+}
+
+func (f *File) checkValid(op string) error {
+	return nil
+}
+
+type rawConn struct{}
+
+func (c *rawConn) Control(f func(uintptr)) error {
+	return nil
+}
+
+func (c *rawConn) Read(f func(uintptr) bool) error {
+	return nil
+}
+
+func (c *rawConn) Write(f func(uintptr) bool) error {
+	return nil
+}
+
+func newRawConn(file *File) (*rawConn, error) {
+	return nil, nil
+}
+
+func ignoringEINTR(fn func() error) error {
+	return fn()
+}
diff --git a/src/os/path_opensbi.go b/src/os/path_opensbi.go
new file mode 100644
index 0000000000..a54b4b98f1
--- /dev/null
+++ b/src/os/path_opensbi.go
@@ -0,0 +1,19 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+const (
+	PathSeparator     = '/'    // OS-specific path separator
+	PathListSeparator = '\000' // OS-specific path list separator
+)
+
+// IsPathSeparator reports whether c is a directory separator character.
+func IsPathSeparator(c uint8) bool {
+	return PathSeparator == c
+}
+
+func fixRootDirectory(p string) string {
+	return p
+}
diff --git a/src/os/rawconn.go b/src/os/rawconn.go
index ffc598b061..c65ed12523 100644
--- a/src/os/rawconn.go
+++ b/src/os/rawconn.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !plan9
-// +build !plan9
+//go:build !plan9 && !opensbi
+// +build !plan9,!opensbi
 
 package os
 
diff --git a/src/os/stat_opensbi.go b/src/os/stat_opensbi.go
new file mode 100644
index 0000000000..b42ed897dd
--- /dev/null
+++ b/src/os/stat_opensbi.go
@@ -0,0 +1,26 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+import (
+	"syscall"
+)
+
+func fileInfoFromStat(d *syscall.Dir) *fileStat {
+	return nil
+}
+
+// arg is an open *File or a path string.
+func dirstat(arg interface{}) (*syscall.Dir, error) {
+	return nil, nil
+}
+
+func statNolog(name string) (FileInfo, error) {
+	return nil, nil
+}
+
+func lstatNolog(name string) (FileInfo, error) {
+	return nil, nil
+}
diff --git a/src/os/sys_opensbi.go b/src/os/sys_opensbi.go
new file mode 100644
index 0000000000..0942d71301
--- /dev/null
+++ b/src/os/sys_opensbi.go
@@ -0,0 +1,9 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package os
+
+func hostname() (name string, err error) {
+	return "", nil
+}
diff --git a/src/runtime/cputicks.go b/src/runtime/cputicks.go
index 7c926f4a2b..5228778bb3 100644
--- a/src/runtime/cputicks.go
+++ b/src/runtime/cputicks.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !arm && !arm64 && !mips64 && !mips64le && !mips && !mipsle && !wasm
-// +build !arm,!arm64,!mips64,!mips64le,!mips,!mipsle,!wasm
+//go:build !arm && !arm64 && !mips64 && !mips64le && !mips && !mipsle && !opensbi && !wasm
+// +build !arm,!arm64,!mips64,!mips64le,!mips,!mipsle,!opensbi, !wasm
 
 package runtime
 
diff --git a/src/runtime/env_posix.go b/src/runtime/env_posix.go
index 95517b2a95..2bd3769855 100644
--- a/src/runtime/env_posix.go
+++ b/src/runtime/env_posix.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris || windows || plan9
-// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris windows plan9
+//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || opensbi || solaris || windows || plan9
+// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd opensbi solaris windows plan9
 
 package runtime
 
diff --git a/src/runtime/lock_opensbi.go b/src/runtime/lock_opensbi.go
new file mode 100644
index 0000000000..c6a3f929e1
--- /dev/null
+++ b/src/runtime/lock_opensbi.go
@@ -0,0 +1,172 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi && riscv64
+// +build opensbi,riscv64
+
+package runtime
+
+import (
+	_ "unsafe"
+)
+
+// js/wasm has no support for threads yet. There is no preemption.
+
+const (
+	mutex_unlocked = 0
+	mutex_locked   = 1
+
+	note_cleared = 0
+	note_woken   = 1
+	note_timeout = 2
+
+	active_spin     = 4
+	active_spin_cnt = 30
+	passive_spin    = 1
+)
+
+func lock(l *mutex) {
+	lockWithRank(l, getLockRank(l))
+}
+
+func lock2(l *mutex) {
+	if l.key == mutex_locked {
+		// js/wasm is single-threaded so we should never
+		// observe this.
+		throw("self deadlock")
+	}
+	gp := getg()
+	if gp.m.locks < 0 {
+		throw("lock count")
+	}
+	gp.m.locks++
+	l.key = mutex_locked
+}
+
+func unlock(l *mutex) {
+	unlockWithRank(l)
+}
+
+func unlock2(l *mutex) {
+	if l.key == mutex_unlocked {
+		throw("unlock of unlocked lock")
+	}
+	gp := getg()
+	gp.m.locks--
+	if gp.m.locks < 0 {
+		throw("lock count")
+	}
+	l.key = mutex_unlocked
+}
+
+// One-time notifications.
+
+type noteWithTimeout struct {
+	gp       *g
+	deadline int64
+}
+
+var (
+	notes            = make(map[*note]*g)
+	notesWithTimeout = make(map[*note]noteWithTimeout)
+)
+
+func noteclear(n *note) {
+	n.key = note_cleared
+}
+
+func notewakeup(n *note) {
+}
+
+func notesleep(n *note) {
+}
+
+func notetsleep(n *note, ns int64) bool {
+	return false
+}
+
+// same as runtime·notetsleep, but called on user g (not g0)
+func notetsleepg(n *note, ns int64) bool {
+	return false
+}
+
+// checkTimeouts resumes goroutines that are waiting on a note which has reached its deadline.
+func checkTimeouts() {
+	now := nanotime()
+	for n, nt := range notesWithTimeout {
+		if n.key == note_cleared && now >= nt.deadline {
+			n.key = note_timeout
+			goready(nt.gp, 1)
+		}
+	}
+}
+
+// events is a stack of calls from JavaScript into Go.
+var events []*event
+
+type event struct {
+	// g was the active goroutine when the call from JavaScript occurred.
+	// It needs to be active when returning to JavaScript.
+	gp *g
+	// returned reports whether the event handler has returned.
+	// When all goroutines are idle and the event handler has returned,
+	// then g gets resumed and returns the execution to JavaScript.
+	returned bool
+}
+
+// The timeout event started by beforeIdle.
+var idleID int32
+
+// beforeIdle gets called by the scheduler if no goroutine is awake.
+// If we are not already handling an event, then we pause for an async event.
+// If an event handler returned, we resume it and it will pause the execution.
+// beforeIdle either returns the specific goroutine to schedule next or
+// indicates with otherReady that some goroutine became ready.
+func beforeIdle(now, pollUntil int64) (gp *g, otherReady bool) {
+	return nil, false
+}
+
+func handleAsyncEvent() {
+	pause(getcallersp() - 16)
+}
+
+// clearIdleID clears our record of the timeout started by beforeIdle.
+func clearIdleID() {
+}
+
+// pause sets SP to newsp and pauses the execution of Go's WebAssembly code until an event is triggered.
+func pause(newsp uintptr)
+
+// handleEvent gets invoked on a call from JavaScript into Go. It calls the event handler of the syscall/js package
+// and then parks the handler goroutine to allow other goroutines to run before giving execution back to JavaScript.
+// When no other goroutine is awake any more, beforeIdle resumes the handler goroutine. Now that the same goroutine
+// is running as was running when the call came in from JavaScript, execution can be safely passed back to JavaScript.
+func handleEvent() {
+	e := &event{
+		gp:       getg(),
+		returned: false,
+	}
+	events = append(events, e)
+
+	eventHandler()
+
+	clearIdleID()
+
+	// wait until all goroutines are idle
+	e.returned = true
+	gopark(nil, nil, waitReasonZero, traceEvNone, 1)
+
+	events[len(events)-1] = nil
+	events = events[:len(events)-1]
+
+	// return execution to JavaScript
+	pause(getcallersp() - 16)
+}
+
+var eventHandler func()
+
+//go:linkname setEventHandler syscall/js.setEventHandler
+func setEventHandler(fn func()) {
+	eventHandler = fn
+}
diff --git a/src/runtime/mem_opensbi.go b/src/runtime/mem_opensbi.go
new file mode 100644
index 0000000000..7102d88ffb
--- /dev/null
+++ b/src/runtime/mem_opensbi.go
@@ -0,0 +1,48 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi && riscv64
+// +build opensbi,riscv64
+
+package runtime
+
+import (
+	"unsafe"
+)
+
+// Don't split the stack as this function may be invoked without a valid G,
+// which prevents us from allocating more stack.
+//go:nosplit
+func sysAlloc(n uintptr, sysStat *sysMemStat) unsafe.Pointer {
+	p := sysReserve(nil, n)
+	sysMap(p, n, sysStat)
+	return p
+}
+
+func sysUnused(v unsafe.Pointer, n uintptr) {
+}
+
+func sysUsed(v unsafe.Pointer, n uintptr) {
+}
+
+func sysHugePage(v unsafe.Pointer, n uintptr) {
+}
+
+// Don't split the stack as this function may be invoked without a valid G,
+// which prevents us from allocating more stack.
+//go:nosplit
+func sysFree(v unsafe.Pointer, n uintptr, sysStat *sysMemStat) {
+	sysStat.add(-int64(n))
+}
+
+func sysFault(v unsafe.Pointer, n uintptr) {
+}
+
+func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer {
+	return v
+}
+
+func sysMap(v unsafe.Pointer, n uintptr, sysStat *sysMemStat) {
+	sysStat.add(int64(n))
+}
diff --git a/src/runtime/netpoll_stub.go b/src/runtime/netpoll_stub.go
index 33ab8eba58..2f40f67915 100644
--- a/src/runtime/netpoll_stub.go
+++ b/src/runtime/netpoll_stub.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build plan9
-// +build plan9
+//go:build plan9 || opensbi
+// +build plan9 opensbi
 
 package runtime
 
diff --git a/src/runtime/os_opensbi.go b/src/runtime/os_opensbi.go
new file mode 100644
index 0000000000..c6b44995da
--- /dev/null
+++ b/src/runtime/os_opensbi.go
@@ -0,0 +1,173 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi && riscv64
+// +build opensbi,riscv64
+
+package runtime
+
+import (
+	"unsafe"
+)
+
+func exit(code int32) {
+	return
+}
+
+func write1(fd uintptr, p unsafe.Pointer, n int32) int32 {
+	return 0
+}
+
+// Stubs so tests can link correctly. These should never be called.
+func open(name *byte, mode, perm int32) int32        { panic("not implemented") }
+func closefd(fd int32) int32                         { panic("not implemented") }
+func read(fd int32, p unsafe.Pointer, n int32) int32 { panic("not implemented") }
+
+func usleep(usec uint32) {
+	return
+}
+
+//go:nosplit
+func usleep_no_g(usec uint32) {
+	usleep(usec)
+}
+
+func exitThread(wait *uint32) {
+	return
+}
+
+type mOS struct{}
+
+func osyield() {
+	return
+}
+
+//go:nosplit
+func osyield_no_g() {
+	osyield()
+}
+
+const _SIGSEGV = 0xb
+
+func sigpanic() {
+	g := getg()
+	if !canpanic(g) {
+		throw("unexpected signal during runtime execution")
+	}
+
+	// js only invokes the exception handler for memory faults.
+	g.sig = _SIGSEGV
+	panicmem()
+}
+
+type sigset struct{}
+
+// Called to initialize a new m (including the bootstrap m).
+// Called on the parent thread (main thread in case of bootstrap), can allocate memory.
+func mpreinit(mp *m) {
+	mp.gsignal = malg(32 * 1024)
+	mp.gsignal.m = mp
+}
+
+//go:nosplit
+func sigsave(p *sigset) {
+}
+
+//go:nosplit
+func msigrestore(sigmask sigset) {
+}
+
+//go:nosplit
+//go:nowritebarrierrec
+func clearSignalHandlers() {
+}
+
+//go:nosplit
+func sigblock(exiting bool) {
+}
+
+// Called to initialize a new m (including the bootstrap m).
+// Called on the new thread, cannot allocate memory.
+func minit() {
+}
+
+// Called from dropm to undo the effect of an minit.
+func unminit() {
+}
+
+// Called from exitm, but not from drop, to undo the effect of thread-owned
+// resources in minit, semacreate, or elsewhere. Do not take locks after calling this.
+func mdestroy(mp *m) {
+}
+
+func osinit() {
+	ncpu = 1
+	getg().m.procid = 2
+	physPageSize = 64 * 1024
+}
+
+// wasm has no signals
+const _NSIG = 0
+
+func signame(sig uint32) string {
+	return ""
+}
+
+func crash() {
+	*(*int32)(nil) = 0
+}
+
+func getRandomData(r []byte) {
+	return
+}
+
+func goenvs() {
+	goenvs_unix()
+}
+
+func initsig(preinit bool) {
+}
+
+// May run with m.p==nil, so write barriers are not allowed.
+//go:nowritebarrier
+func newosproc(mp *m) {
+	panic("newosproc: not implemented")
+}
+
+func setProcessCPUProfiler(hz int32) {}
+func setThreadCPUProfiler(hz int32)  {}
+func sigdisable(uint32)              {}
+func sigenable(uint32)               {}
+func sigignore(uint32)               {}
+
+//go:linkname os_sigpipe os.sigpipe
+func os_sigpipe() {
+	throw("too many writes on closed pipe")
+}
+
+//go:nosplit
+func cputicks() int64
+
+//go:linkname syscall_now syscall.now
+func syscall_now() (sec int64, nsec int32) {
+	sec, nsec, _ = time_now()
+	return
+}
+
+// gsignalStack is unused on js.
+type gsignalStack struct{}
+
+const preemptMSupported = false
+
+func preemptM(mp *m) {
+	// No threads, so nothing to do.
+}
+
+func nanotime1() int64 {
+	return 0
+}
+
+func walltime() (sec int64, nsec int32) {
+	return
+}
diff --git a/src/runtime/rt0_opensbi_riscv64.s b/src/runtime/rt0_opensbi_riscv64.s
new file mode 100644
index 0000000000..920cc65701
--- /dev/null
+++ b/src/runtime/rt0_opensbi_riscv64.s
@@ -0,0 +1,14 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "textflag.h"
+
+TEXT _rt0_riscv64_opensbi(SB),NOSPLIT|NOFRAME,$0
+	MOV	0(X2), A0	// argc
+	ADD	$8, X2, A1	// argv
+	JMP	main(SB)
+
+TEXT main(SB),NOSPLIT|NOFRAME,$0
+	MOV	$runtime·rt0_go(SB), T0
+	JALR	ZERO, T0
diff --git a/src/runtime/stubs2.go b/src/runtime/stubs2.go
index 525b324c81..1d6b0af1d2 100644
--- a/src/runtime/stubs2.go
+++ b/src/runtime/stubs2.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !aix && !darwin && !js && !openbsd && !plan9 && !solaris && !windows
-// +build !aix,!darwin,!js,!openbsd,!plan9,!solaris,!windows
+//go:build !aix && !darwin && !js && !openbsd && !opensbi && !plan9 && !solaris && !windows
+// +build !aix,!darwin,!js,!openbsd,!opensbi,!plan9,!solaris,!windows
 
 package runtime
 
diff --git a/src/runtime/stubs3.go b/src/runtime/stubs3.go
index b895be4c70..f4a451182f 100644
--- a/src/runtime/stubs3.go
+++ b/src/runtime/stubs3.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !aix && !darwin && !freebsd && !openbsd && !plan9 && !solaris
-// +build !aix,!darwin,!freebsd,!openbsd,!plan9,!solaris
+//go:build !aix && !darwin && !freebsd && !openbsd && !opensbi && !plan9 && !solaris
+// +build !aix,!darwin,!freebsd,!openbsd,!opensbi,!plan9,!solaris
 
 package runtime
 
diff --git a/src/runtime/timestub2.go b/src/runtime/timestub2.go
index 800a2a94e0..3f72cba046 100644
--- a/src/runtime/timestub2.go
+++ b/src/runtime/timestub2.go
@@ -2,11 +2,12 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !aix && !darwin && !freebsd && !openbsd && !solaris && !windows && !(linux && amd64)
+//go:build !aix && !darwin && !freebsd && !openbsd && !opensbi && !solaris && !windows && !(linux && amd64)
 // +build !aix
 // +build !darwin
 // +build !freebsd
 // +build !openbsd
+// +build !opensbi
 // +build !solaris
 // +build !windows
 // +build !linux !amd64
diff --git a/src/syscall/dir_opensbi.go b/src/syscall/dir_opensbi.go
new file mode 100644
index 0000000000..c921067b33
--- /dev/null
+++ b/src/syscall/dir_opensbi.go
@@ -0,0 +1,33 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+type Dir struct {
+	Mode   uint32 // permissions
+	Atime  uint32 // last read time
+	Mtime  uint32 // last write time
+	Length int64  // file length
+	Name   string // last element of path
+	Uid    string // owner name
+	Gid    string // group name
+	Muid   string // last modifier name
+}
+
+var nullDir = Dir{
+	Mode:   ^uint32(0),
+	Atime:  ^uint32(0),
+	Mtime:  ^uint32(0),
+	Length: ^int64(0),
+}
+
+func (d *Dir) Null() { *d = nullDir }
+
+func (d *Dir) Marshal(b []byte) (n int, err error) {
+	return 0, nil
+}
+
+func UnmarshalDir(b []byte) (*Dir, error) {
+	return nil, nil
+}
diff --git a/src/syscall/dirent.go b/src/syscall/dirent.go
index 9e1222e81c..5b1a399e65 100644
--- a/src/syscall/dirent.go
+++ b/src/syscall/dirent.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris
-// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris
+//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || opensbi || solaris
+// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd opensbi solaris
 
 package syscall
 
diff --git a/src/syscall/env_opensbi.go b/src/syscall/env_opensbi.go
new file mode 100644
index 0000000000..1b5cd9b485
--- /dev/null
+++ b/src/syscall/env_opensbi.go
@@ -0,0 +1,26 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+func Getenv(key string) (value string, found bool) {
+	return "", false
+}
+
+func Setenv(key, value string) error {
+	return nil
+}
+
+func Unsetenv(key string) error {
+	return nil
+}
+
+func Clearenv() {
+	return
+}
+
+func Environ() []string {
+	r := make([]string, 0) // Empty with room to grow.
+	return r
+}
diff --git a/src/syscall/fs_opensbi.go b/src/syscall/fs_opensbi.go
new file mode 100644
index 0000000000..d99db26d1f
--- /dev/null
+++ b/src/syscall/fs_opensbi.go
@@ -0,0 +1,131 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi && riscv64
+// +build opensbi,riscv64
+
+package syscall
+
+// Provided by package runtime.
+func now() (sec int64, nsec int32)
+
+func CloseOnExec(fd int) {
+	// nothing to do - no exec
+}
+
+func Mkdir(path string, perm uint32) error {
+	return nil
+}
+
+func ReadDirent(fd int, buf []byte) (int, error) {
+	return 0, nil
+}
+
+func Stat(path string, st *Stat_t) error {
+	return nil
+}
+
+func Lstat(path string, st *Stat_t) error {
+	return nil
+}
+
+func Fstat(fd int, st *Stat_t) error {
+	return nil
+}
+
+func Unlink(path string) error {
+	return nil
+}
+
+func Rmdir(path string) error {
+	return nil
+}
+
+func Chmod(path string, mode uint32) error {
+	return nil
+}
+
+func Fchmod(fd int, mode uint32) error {
+	return nil
+}
+
+func Chown(path string, uid, gid int) error {
+	return nil
+}
+
+func Fchown(fd int, uid, gid int) error {
+	return nil
+}
+
+func Lchown(path string, uid, gid int) error {
+	return nil
+}
+
+func UtimesNano(path string, ts []Timespec) error {
+	return nil
+}
+
+func Rename(from, to string) error {
+	return nil
+}
+
+func Truncate(path string, length int64) error {
+	return nil
+}
+
+func Ftruncate(fd int, length int64) error {
+	return nil
+}
+
+func Getcwd(buf []byte) (n int, err error) {
+	return 0, nil
+}
+
+func Chdir(path string) (err error) {
+	return nil
+}
+
+func Fchdir(fd int) error {
+	return nil
+}
+
+func Readlink(path string, buf []byte) (n int, err error) {
+	return 0, nil
+}
+
+func Link(path, link string) error {
+	return nil
+}
+
+func Symlink(path, link string) error {
+	return nil
+}
+
+func Fsync(fd int) error {
+	return nil
+}
+
+func Write(fd int, b []byte) (int, error) {
+	return 0, nil
+}
+
+func Pread(fd int, b []byte, offset int64) (int, error) {
+	return 0, nil
+}
+
+func Pwrite(fd int, b []byte, offset int64) (int, error) {
+	return 0, nil
+}
+
+func Dup(fd int) (int, error) {
+	return 0, nil
+}
+
+func Dup2(fd, newfd int) error {
+	return nil
+}
+
+func Pipe(fd []int) error {
+	return ENOSYS
+}
diff --git a/src/syscall/syscall_opensbi.go b/src/syscall/syscall_opensbi.go
new file mode 100644
index 0000000000..43aaa89755
--- /dev/null
+++ b/src/syscall/syscall_opensbi.go
@@ -0,0 +1,364 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi && riscv64
+// +build opensbi,riscv64
+
+package syscall
+
+import (
+	"internal/itoa"
+	"internal/oserror"
+	"sync"
+	"unsafe"
+)
+
+const direntSize = 8 + 8 + 2 + 256
+
+type Dirent struct {
+	Reclen uint16
+	Name   [256]byte
+}
+
+func direntIno(buf []byte) (uint64, bool) {
+	return 1, true
+}
+
+func direntReclen(buf []byte) (uint64, bool) {
+	return readInt(buf, unsafe.Offsetof(Dirent{}.Reclen), unsafe.Sizeof(Dirent{}.Reclen))
+}
+
+func direntNamlen(buf []byte) (uint64, bool) {
+	reclen, ok := direntReclen(buf)
+	if !ok {
+		return 0, false
+	}
+	return reclen - uint64(unsafe.Offsetof(Dirent{}.Name)), true
+}
+
+const PathMax = 256
+
+// An Errno is an unsigned number describing an error condition.
+// It implements the error interface. The zero Errno is by convention
+// a non-error, so code to convert from Errno to error should use:
+//	err = nil
+//	if errno != 0 {
+//		err = errno
+//	}
+//
+// Errno values can be tested against error values from the os package
+// using errors.Is. For example:
+//
+//	_, _, err := syscall.Syscall(...)
+//	if errors.Is(err, fs.ErrNotExist) ...
+type Errno uintptr
+
+func (e Errno) Error() string {
+	if 0 <= int(e) && int(e) < len(errorstr) {
+		s := errorstr[e]
+		if s != "" {
+			return s
+		}
+	}
+	return "errno " + itoa.Itoa(int(e))
+}
+
+func (e Errno) Is(target error) bool {
+	switch target {
+	case oserror.ErrPermission:
+		return e == EACCES || e == EPERM
+	case oserror.ErrExist:
+		return e == EEXIST || e == ENOTEMPTY
+	case oserror.ErrNotExist:
+		return e == ENOENT
+	}
+	return false
+}
+
+func (e Errno) Temporary() bool {
+	return e == EINTR || e == EMFILE || e.Timeout()
+}
+
+func (e Errno) Timeout() bool {
+	return e == EAGAIN || e == EWOULDBLOCK || e == ETIMEDOUT
+}
+
+// A Signal is a number describing a process signal.
+// It implements the os.Signal interface.
+type Signal int
+
+const (
+	_ Signal = iota
+	SIGCHLD
+	SIGINT
+	SIGKILL
+	SIGTRAP
+	SIGQUIT
+	SIGTERM
+)
+
+func (s Signal) Signal() {}
+
+func (s Signal) String() string {
+	if 0 <= s && int(s) < len(signals) {
+		str := signals[s]
+		if str != "" {
+			return str
+		}
+	}
+	return "signal " + itoa.Itoa(int(s))
+}
+
+var signals = [...]string{}
+
+// File system
+
+const (
+	Stdin  = 0
+	Stdout = 1
+	Stderr = 2
+)
+
+const (
+	O_RDONLY = 0
+	O_WRONLY = 1
+	O_RDWR   = 2
+
+	O_CREAT  = 0100
+	O_CREATE = O_CREAT
+	O_TRUNC  = 01000
+	O_APPEND = 02000
+	O_EXCL   = 0200
+	O_SYNC   = 010000
+
+	O_CLOEXEC = 0
+)
+
+const (
+	F_DUPFD   = 0
+	F_GETFD   = 1
+	F_SETFD   = 2
+	F_GETFL   = 3
+	F_SETFL   = 4
+	F_GETOWN  = 5
+	F_SETOWN  = 6
+	F_GETLK   = 7
+	F_SETLK   = 8
+	F_SETLKW  = 9
+	F_RGETLK  = 10
+	F_RSETLK  = 11
+	F_CNVT    = 12
+	F_RSETLKW = 13
+
+	F_RDLCK   = 1
+	F_WRLCK   = 2
+	F_UNLCK   = 3
+	F_UNLKSYS = 4
+)
+
+const (
+	S_IFMT        = 0000370000
+	S_IFSHM_SYSV  = 0000300000
+	S_IFSEMA      = 0000270000
+	S_IFCOND      = 0000260000
+	S_IFMUTEX     = 0000250000
+	S_IFSHM       = 0000240000
+	S_IFBOUNDSOCK = 0000230000
+	S_IFSOCKADDR  = 0000220000
+	S_IFDSOCK     = 0000210000
+
+	S_IFSOCK = 0000140000
+	S_IFLNK  = 0000120000
+	S_IFREG  = 0000100000
+	S_IFBLK  = 0000060000
+	S_IFDIR  = 0000040000
+	S_IFCHR  = 0000020000
+	S_IFIFO  = 0000010000
+
+	S_UNSUP = 0000370000
+
+	S_ISUID = 0004000
+	S_ISGID = 0002000
+	S_ISVTX = 0001000
+
+	S_IREAD  = 0400
+	S_IWRITE = 0200
+	S_IEXEC  = 0100
+
+	S_IRWXU = 0700
+	S_IRUSR = 0400
+	S_IWUSR = 0200
+	S_IXUSR = 0100
+
+	S_IRWXG = 070
+	S_IRGRP = 040
+	S_IWGRP = 020
+	S_IXGRP = 010
+
+	S_IRWXO = 07
+	S_IROTH = 04
+	S_IWOTH = 02
+	S_IXOTH = 01
+)
+
+type Stat_t struct {
+	Dev       int64
+	Ino       uint64
+	Mode      uint32
+	Nlink     uint32
+	Uid       uint32
+	Gid       uint32
+	Rdev      int64
+	Size      int64
+	Blksize   int32
+	Blocks    int32
+	Atime     int64
+	AtimeNsec int64
+	Mtime     int64
+	MtimeNsec int64
+	Ctime     int64
+	CtimeNsec int64
+}
+
+// Processes
+// Not supported - just enough for package os.
+
+var ForkLock sync.RWMutex
+
+type WaitStatus uint32
+
+func (w WaitStatus) Exited() bool       { return false }
+func (w WaitStatus) ExitStatus() int    { return 0 }
+func (w WaitStatus) Signaled() bool     { return false }
+func (w WaitStatus) Signal() Signal     { return 0 }
+func (w WaitStatus) CoreDump() bool     { return false }
+func (w WaitStatus) Stopped() bool      { return false }
+func (w WaitStatus) Continued() bool    { return false }
+func (w WaitStatus) StopSignal() Signal { return 0 }
+func (w WaitStatus) TrapCause() int     { return 0 }
+
+// XXX made up
+type Rusage struct {
+	Utime Timeval
+	Stime Timeval
+}
+
+// XXX made up
+type ProcAttr struct {
+	Dir   string
+	Env   []string
+	Files []uintptr
+	Sys   *SysProcAttr
+}
+
+type SysProcAttr struct {
+}
+
+func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) {
+	return 0, 0, ENOSYS
+}
+
+func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) {
+	return 0, 0, ENOSYS
+}
+
+func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) {
+	return 0, 0, ENOSYS
+}
+
+func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) {
+	return 0, 0, ENOSYS
+}
+
+func Sysctl(key string) (string, error) {
+	if key == "kern.hostname" {
+		return "js", nil
+	}
+	return "", ENOSYS
+}
+
+const ImplementsGetwd = true
+
+func Getwd() (wd string, err error) {
+	return "", nil
+}
+
+func Getuid() int {
+	return 0
+}
+
+func Getgid() int {
+	return 0
+}
+
+func Geteuid() int {
+	return 0
+}
+
+func Getegid() int {
+	return 0
+}
+
+func Getgroups() (groups []int, err error) {
+	groups = make([]int, 0)
+	return groups, nil
+}
+
+func Getpid() int {
+	return 0
+}
+
+func Getppid() int {
+	return 0
+}
+
+func Umask(mask int) (oldmask int) {
+	return 0
+}
+
+func Gettimeofday(tv *Timeval) error { return ENOSYS }
+
+func Kill(pid int, signum Signal) error { return ENOSYS }
+func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
+	return 0, ENOSYS
+}
+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {
+	return 0, 0, ENOSYS
+}
+func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {
+	return 0, ENOSYS
+}
+
+type Iovec struct{} // dummy
+
+type Timespec struct {
+	Sec  int64
+	Nsec int64
+}
+
+type Timeval struct {
+	Sec  int64
+	Usec int64
+}
+
+func setTimespec(sec, nsec int64) Timespec {
+	return Timespec{Sec: sec, Nsec: nsec}
+}
+
+func setTimeval(sec, usec int64) Timeval {
+	return Timeval{Sec: sec, Usec: usec}
+}
+
+func Seek(fd int, offset int64, whence int) (newoffset int64, err error) {
+	return 0, nil
+}
+func Close(fd int) (err error) {
+	return nil
+}
+func Open(path string, mode int) (fd int, err error) {
+	return 0, nil
+}
+func Read(fd int, p []byte) (n int, err error) {
+	return 0, nil
+}
diff --git a/src/syscall/tables_opensbi.go b/src/syscall/tables_opensbi.go
new file mode 100644
index 0000000000..9c71354c1d
--- /dev/null
+++ b/src/syscall/tables_opensbi.go
@@ -0,0 +1,495 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi && riscv64
+// +build opensbi,riscv64
+
+package syscall
+
+import "runtime"
+
+// These were originally used by Nacl, then later also used by
+// js/wasm. Now that they're only used by js/wasm, these numbers are
+// just arbitrary.
+//
+// TODO: delete? replace with something meaningful?
+const (
+	sys_null                 = 1
+	sys_nameservice          = 2
+	sys_dup                  = 8
+	sys_dup2                 = 9
+	sys_open                 = 10
+	sys_close                = 11
+	sys_read                 = 12
+	sys_write                = 13
+	sys_lseek                = 14
+	sys_stat                 = 16
+	sys_fstat                = 17
+	sys_chmod                = 18
+	sys_isatty               = 19
+	sys_brk                  = 20
+	sys_mmap                 = 21
+	sys_munmap               = 22
+	sys_getdents             = 23
+	sys_mprotect             = 24
+	sys_list_mappings        = 25
+	sys_exit                 = 30
+	sys_getpid               = 31
+	sys_sched_yield          = 32
+	sys_sysconf              = 33
+	sys_gettimeofday         = 40
+	sys_clock                = 41
+	sys_nanosleep            = 42
+	sys_clock_getres         = 43
+	sys_clock_gettime        = 44
+	sys_mkdir                = 45
+	sys_rmdir                = 46
+	sys_chdir                = 47
+	sys_getcwd               = 48
+	sys_unlink               = 49
+	sys_imc_makeboundsock    = 60
+	sys_imc_accept           = 61
+	sys_imc_connect          = 62
+	sys_imc_sendmsg          = 63
+	sys_imc_recvmsg          = 64
+	sys_imc_mem_obj_create   = 65
+	sys_imc_socketpair       = 66
+	sys_mutex_create         = 70
+	sys_mutex_lock           = 71
+	sys_mutex_trylock        = 72
+	sys_mutex_unlock         = 73
+	sys_cond_create          = 74
+	sys_cond_wait            = 75
+	sys_cond_signal          = 76
+	sys_cond_broadcast       = 77
+	sys_cond_timed_wait_abs  = 79
+	sys_thread_create        = 80
+	sys_thread_exit          = 81
+	sys_tls_init             = 82
+	sys_thread_nice          = 83
+	sys_tls_get              = 84
+	sys_second_tls_set       = 85
+	sys_second_tls_get       = 86
+	sys_exception_handler    = 87
+	sys_exception_stack      = 88
+	sys_exception_clear_flag = 89
+	sys_sem_create           = 100
+	sys_sem_wait             = 101
+	sys_sem_post             = 102
+	sys_sem_get_value        = 103
+	sys_dyncode_create       = 104
+	sys_dyncode_modify       = 105
+	sys_dyncode_delete       = 106
+	sys_test_infoleak        = 109
+	sys_test_crash           = 110
+	sys_test_syscall_1       = 111
+	sys_test_syscall_2       = 112
+	sys_futex_wait_abs       = 120
+	sys_futex_wake           = 121
+	sys_pread                = 130
+	sys_pwrite               = 131
+	sys_truncate             = 140
+	sys_lstat                = 141
+	sys_link                 = 142
+	sys_rename               = 143
+	sys_symlink              = 144
+	sys_access               = 145
+	sys_readlink             = 146
+	sys_utimes               = 147
+	sys_get_random_bytes     = 150
+)
+
+// TODO: Auto-generate some day. (Hard-coded in binaries so not likely to change.)
+const (
+	// native_client/src/trusted/service_runtime/include/sys/errno.h
+	// The errors are mainly copied from Linux.
+	EPERM           Errno = 1       /* Operation not permitted */
+	ENOENT          Errno = 2       /* No such file or directory */
+	ESRCH           Errno = 3       /* No such process */
+	EINTR           Errno = 4       /* Interrupted system call */
+	EIO             Errno = 5       /* I/O error */
+	ENXIO           Errno = 6       /* No such device or address */
+	E2BIG           Errno = 7       /* Argument list too long */
+	ENOEXEC         Errno = 8       /* Exec format error */
+	EBADF           Errno = 9       /* Bad file number */
+	ECHILD          Errno = 10      /* No child processes */
+	EAGAIN          Errno = 11      /* Try again */
+	ENOMEM          Errno = 12      /* Out of memory */
+	EACCES          Errno = 13      /* Permission denied */
+	EFAULT          Errno = 14      /* Bad address */
+	EBUSY           Errno = 16      /* Device or resource busy */
+	EEXIST          Errno = 17      /* File exists */
+	EXDEV           Errno = 18      /* Cross-device link */
+	ENODEV          Errno = 19      /* No such device */
+	ENOTDIR         Errno = 20      /* Not a directory */
+	EISDIR          Errno = 21      /* Is a directory */
+	EINVAL          Errno = 22      /* Invalid argument */
+	ENFILE          Errno = 23      /* File table overflow */
+	EMFILE          Errno = 24      /* Too many open files */
+	ENOTTY          Errno = 25      /* Not a typewriter */
+	EFBIG           Errno = 27      /* File too large */
+	ENOSPC          Errno = 28      /* No space left on device */
+	ESPIPE          Errno = 29      /* Illegal seek */
+	EROFS           Errno = 30      /* Read-only file system */
+	EMLINK          Errno = 31      /* Too many links */
+	EPIPE           Errno = 32      /* Broken pipe */
+	ENAMETOOLONG    Errno = 36      /* File name too long */
+	ENOSYS          Errno = 38      /* Function not implemented */
+	EDQUOT          Errno = 122     /* Quota exceeded */
+	EDOM            Errno = 33      /* Math arg out of domain of func */
+	ERANGE          Errno = 34      /* Math result not representable */
+	EDEADLK         Errno = 35      /* Deadlock condition */
+	ENOLCK          Errno = 37      /* No record locks available */
+	ENOTEMPTY       Errno = 39      /* Directory not empty */
+	ELOOP           Errno = 40      /* Too many symbolic links */
+	ENOMSG          Errno = 42      /* No message of desired type */
+	EIDRM           Errno = 43      /* Identifier removed */
+	ECHRNG          Errno = 44      /* Channel number out of range */
+	EL2NSYNC        Errno = 45      /* Level 2 not synchronized */
+	EL3HLT          Errno = 46      /* Level 3 halted */
+	EL3RST          Errno = 47      /* Level 3 reset */
+	ELNRNG          Errno = 48      /* Link number out of range */
+	EUNATCH         Errno = 49      /* Protocol driver not attached */
+	ENOCSI          Errno = 50      /* No CSI structure available */
+	EL2HLT          Errno = 51      /* Level 2 halted */
+	EBADE           Errno = 52      /* Invalid exchange */
+	EBADR           Errno = 53      /* Invalid request descriptor */
+	EXFULL          Errno = 54      /* Exchange full */
+	ENOANO          Errno = 55      /* No anode */
+	EBADRQC         Errno = 56      /* Invalid request code */
+	EBADSLT         Errno = 57      /* Invalid slot */
+	EDEADLOCK       Errno = EDEADLK /* File locking deadlock error */
+	EBFONT          Errno = 59      /* Bad font file fmt */
+	ENOSTR          Errno = 60      /* Device not a stream */
+	ENODATA         Errno = 61      /* No data (for no delay io) */
+	ETIME           Errno = 62      /* Timer expired */
+	ENOSR           Errno = 63      /* Out of streams resources */
+	ENONET          Errno = 64      /* Machine is not on the network */
+	ENOPKG          Errno = 65      /* Package not installed */
+	EREMOTE         Errno = 66      /* The object is remote */
+	ENOLINK         Errno = 67      /* The link has been severed */
+	EADV            Errno = 68      /* Advertise error */
+	ESRMNT          Errno = 69      /* Srmount error */
+	ECOMM           Errno = 70      /* Communication error on send */
+	EPROTO          Errno = 71      /* Protocol error */
+	EMULTIHOP       Errno = 72      /* Multihop attempted */
+	EDOTDOT         Errno = 73      /* Cross mount point (not really error) */
+	EBADMSG         Errno = 74      /* Trying to read unreadable message */
+	EOVERFLOW       Errno = 75      /* Value too large for defined data type */
+	ENOTUNIQ        Errno = 76      /* Given log. name not unique */
+	EBADFD          Errno = 77      /* f.d. invalid for this operation */
+	EREMCHG         Errno = 78      /* Remote address changed */
+	ELIBACC         Errno = 79      /* Can't access a needed shared lib */
+	ELIBBAD         Errno = 80      /* Accessing a corrupted shared lib */
+	ELIBSCN         Errno = 81      /* .lib section in a.out corrupted */
+	ELIBMAX         Errno = 82      /* Attempting to link in too many libs */
+	ELIBEXEC        Errno = 83      /* Attempting to exec a shared library */
+	EILSEQ          Errno = 84
+	EUSERS          Errno = 87
+	ENOTSOCK        Errno = 88  /* Socket operation on non-socket */
+	EDESTADDRREQ    Errno = 89  /* Destination address required */
+	EMSGSIZE        Errno = 90  /* Message too long */
+	EPROTOTYPE      Errno = 91  /* Protocol wrong type for socket */
+	ENOPROTOOPT     Errno = 92  /* Protocol not available */
+	EPROTONOSUPPORT Errno = 93  /* Unknown protocol */
+	ESOCKTNOSUPPORT Errno = 94  /* Socket type not supported */
+	EOPNOTSUPP      Errno = 95  /* Operation not supported on transport endpoint */
+	EPFNOSUPPORT    Errno = 96  /* Protocol family not supported */
+	EAFNOSUPPORT    Errno = 97  /* Address family not supported by protocol family */
+	EADDRINUSE      Errno = 98  /* Address already in use */
+	EADDRNOTAVAIL   Errno = 99  /* Address not available */
+	ENETDOWN        Errno = 100 /* Network interface is not configured */
+	ENETUNREACH     Errno = 101 /* Network is unreachable */
+	ENETRESET       Errno = 102
+	ECONNABORTED    Errno = 103 /* Connection aborted */
+	ECONNRESET      Errno = 104 /* Connection reset by peer */
+	ENOBUFS         Errno = 105 /* No buffer space available */
+	EISCONN         Errno = 106 /* Socket is already connected */
+	ENOTCONN        Errno = 107 /* Socket is not connected */
+	ESHUTDOWN       Errno = 108 /* Can't send after socket shutdown */
+	ETOOMANYREFS    Errno = 109
+	ETIMEDOUT       Errno = 110 /* Connection timed out */
+	ECONNREFUSED    Errno = 111 /* Connection refused */
+	EHOSTDOWN       Errno = 112 /* Host is down */
+	EHOSTUNREACH    Errno = 113 /* Host is unreachable */
+	EALREADY        Errno = 114 /* Socket already connected */
+	EINPROGRESS     Errno = 115 /* Connection already in progress */
+	ESTALE          Errno = 116
+	ENOTSUP         Errno = EOPNOTSUPP /* Not supported */
+	ENOMEDIUM       Errno = 123        /* No medium (in tape drive) */
+	ECANCELED       Errno = 125        /* Operation canceled. */
+	ELBIN           Errno = 2048       /* Inode is remote (not really error) */
+	EFTYPE          Errno = 2049       /* Inappropriate file type or format */
+	ENMFILE         Errno = 2050       /* No more files */
+	EPROCLIM        Errno = 2051
+	ENOSHARE        Errno = 2052   /* No such host or network path */
+	ECASECLASH      Errno = 2053   /* Filename exists with different case */
+	EWOULDBLOCK     Errno = EAGAIN /* Operation would block */
+)
+
+// TODO: Auto-generate some day. (Hard-coded in binaries so not likely to change.)
+var errorstr = [...]string{
+	EPERM:           "Operation not permitted",
+	ENOENT:          "No such file or directory",
+	ESRCH:           "No such process",
+	EINTR:           "Interrupted system call",
+	EIO:             "I/O error",
+	ENXIO:           "No such device or address",
+	E2BIG:           "Argument list too long",
+	ENOEXEC:         "Exec format error",
+	EBADF:           "Bad file number",
+	ECHILD:          "No child processes",
+	EAGAIN:          "Try again",
+	ENOMEM:          "Out of memory",
+	EACCES:          "Permission denied",
+	EFAULT:          "Bad address",
+	EBUSY:           "Device or resource busy",
+	EEXIST:          "File exists",
+	EXDEV:           "Cross-device link",
+	ENODEV:          "No such device",
+	ENOTDIR:         "Not a directory",
+	EISDIR:          "Is a directory",
+	EINVAL:          "Invalid argument",
+	ENFILE:          "File table overflow",
+	EMFILE:          "Too many open files",
+	ENOTTY:          "Not a typewriter",
+	EFBIG:           "File too large",
+	ENOSPC:          "No space left on device",
+	ESPIPE:          "Illegal seek",
+	EROFS:           "Read-only file system",
+	EMLINK:          "Too many links",
+	EPIPE:           "Broken pipe",
+	ENAMETOOLONG:    "File name too long",
+	ENOSYS:          "not implemented on " + runtime.GOOS,
+	EDQUOT:          "Quota exceeded",
+	EDOM:            "Math arg out of domain of func",
+	ERANGE:          "Math result not representable",
+	EDEADLK:         "Deadlock condition",
+	ENOLCK:          "No record locks available",
+	ENOTEMPTY:       "Directory not empty",
+	ELOOP:           "Too many symbolic links",
+	ENOMSG:          "No message of desired type",
+	EIDRM:           "Identifier removed",
+	ECHRNG:          "Channel number out of range",
+	EL2NSYNC:        "Level 2 not synchronized",
+	EL3HLT:          "Level 3 halted",
+	EL3RST:          "Level 3 reset",
+	ELNRNG:          "Link number out of range",
+	EUNATCH:         "Protocol driver not attached",
+	ENOCSI:          "No CSI structure available",
+	EL2HLT:          "Level 2 halted",
+	EBADE:           "Invalid exchange",
+	EBADR:           "Invalid request descriptor",
+	EXFULL:          "Exchange full",
+	ENOANO:          "No anode",
+	EBADRQC:         "Invalid request code",
+	EBADSLT:         "Invalid slot",
+	EBFONT:          "Bad font file fmt",
+	ENOSTR:          "Device not a stream",
+	ENODATA:         "No data (for no delay io)",
+	ETIME:           "Timer expired",
+	ENOSR:           "Out of streams resources",
+	ENONET:          "Machine is not on the network",
+	ENOPKG:          "Package not installed",
+	EREMOTE:         "The object is remote",
+	ENOLINK:         "The link has been severed",
+	EADV:            "Advertise error",
+	ESRMNT:          "Srmount error",
+	ECOMM:           "Communication error on send",
+	EPROTO:          "Protocol error",
+	EMULTIHOP:       "Multihop attempted",
+	EDOTDOT:         "Cross mount point (not really error)",
+	EBADMSG:         "Trying to read unreadable message",
+	EOVERFLOW:       "Value too large for defined data type",
+	ENOTUNIQ:        "Given log. name not unique",
+	EBADFD:          "f.d. invalid for this operation",
+	EREMCHG:         "Remote address changed",
+	ELIBACC:         "Can't access a needed shared lib",
+	ELIBBAD:         "Accessing a corrupted shared lib",
+	ELIBSCN:         ".lib section in a.out corrupted",
+	ELIBMAX:         "Attempting to link in too many libs",
+	ELIBEXEC:        "Attempting to exec a shared library",
+	ENOTSOCK:        "Socket operation on non-socket",
+	EDESTADDRREQ:    "Destination address required",
+	EMSGSIZE:        "Message too long",
+	EPROTOTYPE:      "Protocol wrong type for socket",
+	ENOPROTOOPT:     "Protocol not available",
+	EPROTONOSUPPORT: "Unknown protocol",
+	ESOCKTNOSUPPORT: "Socket type not supported",
+	EOPNOTSUPP:      "Operation not supported on transport endpoint",
+	EPFNOSUPPORT:    "Protocol family not supported",
+	EAFNOSUPPORT:    "Address family not supported by protocol family",
+	EADDRINUSE:      "Address already in use",
+	EADDRNOTAVAIL:   "Address not available",
+	ENETDOWN:        "Network interface is not configured",
+	ENETUNREACH:     "Network is unreachable",
+	ECONNABORTED:    "Connection aborted",
+	ECONNRESET:      "Connection reset by peer",
+	ENOBUFS:         "No buffer space available",
+	EISCONN:         "Socket is already connected",
+	ENOTCONN:        "Socket is not connected",
+	ESHUTDOWN:       "Can't send after socket shutdown",
+	ETIMEDOUT:       "Connection timed out",
+	ECONNREFUSED:    "Connection refused",
+	EHOSTDOWN:       "Host is down",
+	EHOSTUNREACH:    "Host is unreachable",
+	EALREADY:        "Socket already connected",
+	EINPROGRESS:     "Connection already in progress",
+	ENOMEDIUM:       "No medium (in tape drive)",
+	ECANCELED:       "Operation canceled.",
+	ELBIN:           "Inode is remote (not really error)",
+	EFTYPE:          "Inappropriate file type or format",
+	ENMFILE:         "No more files",
+	ENOSHARE:        "No such host or network path",
+	ECASECLASH:      "Filename exists with different case",
+}
+
+// Do the interface allocations only once for common
+// Errno values.
+var (
+	errEAGAIN error = EAGAIN
+	errEINVAL error = EINVAL
+	errENOENT error = ENOENT
+)
+
+// errnoErr returns common boxed Errno values, to prevent
+// allocations at runtime.
+func errnoErr(e Errno) error {
+	switch e {
+	case 0:
+		return nil
+	case EAGAIN:
+		return errEAGAIN
+	case EINVAL:
+		return errEINVAL
+	case ENOENT:
+		return errENOENT
+	}
+	return e
+}
+
+var errnoByCode = map[string]Errno{
+	"EPERM":           EPERM,
+	"ENOENT":          ENOENT,
+	"ESRCH":           ESRCH,
+	"EINTR":           EINTR,
+	"EIO":             EIO,
+	"ENXIO":           ENXIO,
+	"E2BIG":           E2BIG,
+	"ENOEXEC":         ENOEXEC,
+	"EBADF":           EBADF,
+	"ECHILD":          ECHILD,
+	"EAGAIN":          EAGAIN,
+	"ENOMEM":          ENOMEM,
+	"EACCES":          EACCES,
+	"EFAULT":          EFAULT,
+	"EBUSY":           EBUSY,
+	"EEXIST":          EEXIST,
+	"EXDEV":           EXDEV,
+	"ENODEV":          ENODEV,
+	"ENOTDIR":         ENOTDIR,
+	"EISDIR":          EISDIR,
+	"EINVAL":          EINVAL,
+	"ENFILE":          ENFILE,
+	"EMFILE":          EMFILE,
+	"ENOTTY":          ENOTTY,
+	"EFBIG":           EFBIG,
+	"ENOSPC":          ENOSPC,
+	"ESPIPE":          ESPIPE,
+	"EROFS":           EROFS,
+	"EMLINK":          EMLINK,
+	"EPIPE":           EPIPE,
+	"ENAMETOOLONG":    ENAMETOOLONG,
+	"ENOSYS":          ENOSYS,
+	"EDQUOT":          EDQUOT,
+	"EDOM":            EDOM,
+	"ERANGE":          ERANGE,
+	"EDEADLK":         EDEADLK,
+	"ENOLCK":          ENOLCK,
+	"ENOTEMPTY":       ENOTEMPTY,
+	"ELOOP":           ELOOP,
+	"ENOMSG":          ENOMSG,
+	"EIDRM":           EIDRM,
+	"ECHRNG":          ECHRNG,
+	"EL2NSYNC":        EL2NSYNC,
+	"EL3HLT":          EL3HLT,
+	"EL3RST":          EL3RST,
+	"ELNRNG":          ELNRNG,
+	"EUNATCH":         EUNATCH,
+	"ENOCSI":          ENOCSI,
+	"EL2HLT":          EL2HLT,
+	"EBADE":           EBADE,
+	"EBADR":           EBADR,
+	"EXFULL":          EXFULL,
+	"ENOANO":          ENOANO,
+	"EBADRQC":         EBADRQC,
+	"EBADSLT":         EBADSLT,
+	"EDEADLOCK":       EDEADLOCK,
+	"EBFONT":          EBFONT,
+	"ENOSTR":          ENOSTR,
+	"ENODATA":         ENODATA,
+	"ETIME":           ETIME,
+	"ENOSR":           ENOSR,
+	"ENONET":          ENONET,
+	"ENOPKG":          ENOPKG,
+	"EREMOTE":         EREMOTE,
+	"ENOLINK":         ENOLINK,
+	"EADV":            EADV,
+	"ESRMNT":          ESRMNT,
+	"ECOMM":           ECOMM,
+	"EPROTO":          EPROTO,
+	"EMULTIHOP":       EMULTIHOP,
+	"EDOTDOT":         EDOTDOT,
+	"EBADMSG":         EBADMSG,
+	"EOVERFLOW":       EOVERFLOW,
+	"ENOTUNIQ":        ENOTUNIQ,
+	"EBADFD":          EBADFD,
+	"EREMCHG":         EREMCHG,
+	"ELIBACC":         ELIBACC,
+	"ELIBBAD":         ELIBBAD,
+	"ELIBSCN":         ELIBSCN,
+	"ELIBMAX":         ELIBMAX,
+	"ELIBEXEC":        ELIBEXEC,
+	"EILSEQ":          EILSEQ,
+	"EUSERS":          EUSERS,
+	"ENOTSOCK":        ENOTSOCK,
+	"EDESTADDRREQ":    EDESTADDRREQ,
+	"EMSGSIZE":        EMSGSIZE,
+	"EPROTOTYPE":      EPROTOTYPE,
+	"ENOPROTOOPT":     ENOPROTOOPT,
+	"EPROTONOSUPPORT": EPROTONOSUPPORT,
+	"ESOCKTNOSUPPORT": ESOCKTNOSUPPORT,
+	"EOPNOTSUPP":      EOPNOTSUPP,
+	"EPFNOSUPPORT":    EPFNOSUPPORT,
+	"EAFNOSUPPORT":    EAFNOSUPPORT,
+	"EADDRINUSE":      EADDRINUSE,
+	"EADDRNOTAVAIL":   EADDRNOTAVAIL,
+	"ENETDOWN":        ENETDOWN,
+	"ENETUNREACH":     ENETUNREACH,
+	"ENETRESET":       ENETRESET,
+	"ECONNABORTED":    ECONNABORTED,
+	"ECONNRESET":      ECONNRESET,
+	"ENOBUFS":         ENOBUFS,
+	"EISCONN":         EISCONN,
+	"ENOTCONN":        ENOTCONN,
+	"ESHUTDOWN":       ESHUTDOWN,
+	"ETOOMANYREFS":    ETOOMANYREFS,
+	"ETIMEDOUT":       ETIMEDOUT,
+	"ECONNREFUSED":    ECONNREFUSED,
+	"EHOSTDOWN":       EHOSTDOWN,
+	"EHOSTUNREACH":    EHOSTUNREACH,
+	"EALREADY":        EALREADY,
+	"EINPROGRESS":     EINPROGRESS,
+	"ESTALE":          ESTALE,
+	"ENOTSUP":         ENOTSUP,
+	"ENOMEDIUM":       ENOMEDIUM,
+	"ECANCELED":       ECANCELED,
+	"ELBIN":           ELBIN,
+	"EFTYPE":          EFTYPE,
+	"ENMFILE":         ENMFILE,
+	"EPROCLIM":        EPROCLIM,
+	"ENOSHARE":        ENOSHARE,
+	"ECASECLASH":      ECASECLASH,
+	"EWOULDBLOCK":     EWOULDBLOCK,
+}
diff --git a/src/time/sys_opensbi.go b/src/time/sys_opensbi.go
new file mode 100644
index 0000000000..44fa77d87f
--- /dev/null
+++ b/src/time/sys_opensbi.go
@@ -0,0 +1,55 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build opensbi
+// +build opensbi
+
+package time
+
+import (
+	"errors"
+	"syscall"
+)
+
+// for testing: whatever interrupts a sleep
+func interrupt() {
+	// cannot predict pid, don't want to kill group
+}
+
+func open(name string) (uintptr, error) {
+	fd, err := syscall.Open(name, syscall.O_RDONLY)
+	if err != nil {
+		return 0, err
+	}
+	return uintptr(fd), nil
+}
+
+func read(fd uintptr, buf []byte) (int, error) {
+	return syscall.Read(int(fd), buf)
+}
+
+func closefd(fd uintptr) {
+	syscall.Close(int(fd))
+}
+
+func preadn(fd uintptr, buf []byte, off int) error {
+	whence := seekStart
+	if off < 0 {
+		whence = seekEnd
+	}
+	if _, err := syscall.Seek(int(fd), int64(off), whence); err != nil {
+		return err
+	}
+	for len(buf) > 0 {
+		m, err := syscall.Read(int(fd), buf)
+		if m <= 0 {
+			if err == nil {
+				return errors.New("short read")
+			}
+			return err
+		}
+		buf = buf[m:]
+	}
+	return nil
+}
diff --git a/src/time/zoneinfo_opensbi.go b/src/time/zoneinfo_opensbi.go
new file mode 100644
index 0000000000..4ae718c59e
--- /dev/null
+++ b/src/time/zoneinfo_opensbi.go
@@ -0,0 +1,142 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Parse Plan 9 timezone(2) files.
+
+package time
+
+import (
+	"runtime"
+	"syscall"
+)
+
+var zoneSources = []string{
+	runtime.GOROOT() + "/lib/time/zoneinfo.zip",
+}
+
+func isSpace(r rune) bool {
+	return r == ' ' || r == '\t' || r == '\n'
+}
+
+// Copied from strings to avoid a dependency.
+func fields(s string) []string {
+	// First count the fields.
+	n := 0
+	inField := false
+	for _, rune := range s {
+		wasInField := inField
+		inField = !isSpace(rune)
+		if inField && !wasInField {
+			n++
+		}
+	}
+
+	// Now create them.
+	a := make([]string, n)
+	na := 0
+	fieldStart := -1 // Set to -1 when looking for start of field.
+	for i, rune := range s {
+		if isSpace(rune) {
+			if fieldStart >= 0 {
+				a[na] = s[fieldStart:i]
+				na++
+				fieldStart = -1
+			}
+		} else if fieldStart == -1 {
+			fieldStart = i
+		}
+	}
+	if fieldStart >= 0 { // Last field might end at EOF.
+		a[na] = s[fieldStart:]
+	}
+	return a
+}
+
+func loadZoneDataPlan9(s string) (l *Location, err error) {
+	f := fields(s)
+	if len(f) < 4 {
+		if len(f) == 2 && f[0] == "GMT" {
+			return UTC, nil
+		}
+		return nil, badData
+	}
+
+	var zones [2]zone
+
+	// standard timezone offset
+	o, err := atoi(f[1])
+	if err != nil {
+		return nil, badData
+	}
+	zones[0] = zone{name: f[0], offset: o, isDST: false}
+
+	// alternate timezone offset
+	o, err = atoi(f[3])
+	if err != nil {
+		return nil, badData
+	}
+	zones[1] = zone{name: f[2], offset: o, isDST: true}
+
+	// transition time pairs
+	var tx []zoneTrans
+	f = f[4:]
+	for i := 0; i < len(f); i++ {
+		zi := 0
+		if i%2 == 0 {
+			zi = 1
+		}
+		t, err := atoi(f[i])
+		if err != nil {
+			return nil, badData
+		}
+		t -= zones[0].offset
+		tx = append(tx, zoneTrans{when: int64(t), index: uint8(zi)})
+	}
+
+	// Committed to succeed.
+	l = &Location{zone: zones[:], tx: tx}
+
+	// Fill in the cache with information about right now,
+	// since that will be the most common lookup.
+	sec, _, _ := now()
+	for i := range tx {
+		if tx[i].when <= sec && (i+1 == len(tx) || sec < tx[i+1].when) {
+			l.cacheStart = tx[i].when
+			l.cacheEnd = omega
+			if i+1 < len(tx) {
+				l.cacheEnd = tx[i+1].when
+			}
+			l.cacheZone = &l.zone[tx[i].index]
+		}
+	}
+
+	return l, nil
+}
+
+func loadZoneFilePlan9(name string) (*Location, error) {
+	b, err := readFile(name)
+	if err != nil {
+		return nil, err
+	}
+	return loadZoneDataPlan9(string(b))
+}
+
+func initLocal() {
+	t, ok := syscall.Getenv("timezone")
+	if ok {
+		if z, err := loadZoneDataPlan9(t); err == nil {
+			localLoc = *z
+			return
+		}
+	} else {
+		if z, err := loadZoneFilePlan9("/adm/timezone/local"); err == nil {
+			localLoc = *z
+			localLoc.name = "Local"
+			return
+		}
+	}
+
+	// Fall back to UTC.
+	localLoc.name = "UTC"
+}
-- 
2.32.0

